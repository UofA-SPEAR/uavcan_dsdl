// UAVCAN data structure definition.                                                                          +-+ +-+
//                                                                                                            | | | |
// AUTOGENERATED, DO NOT EDIT.                                                                                \  -  /
//                                                                                                              ---
//                                                                                                               o
// +------------------------------------------------------------------------------------------------------------------+
//
// Generator:
// nunavut-0.3.4 (serialization was enabled)
//
//
// Source File:
// /home/david/Documents/Clubs/SPEAR/uavcan_dsdl/public_regulated_data_types/uavcan/register/Value.1.0.uavcan
//
// Template:
// UnionType.j2
//
// Generated at:  2020-08-21 01:54:43.566444 UTC
// Is deprecated: no
// Fixed port ID: None
// Full name:     uavcan.register.Value
// Version:       1.0

#ifndef UAVCAN_REGISTER_VALUE_INCLUDED
#define UAVCAN_REGISTER_VALUE_INCLUDED

#include <nunavut/support/nunavut.h>
#include <uavcan/primitive/Empty_1_0.h>
#include <uavcan/primitive/String_1_0.h>
#include <uavcan/primitive/Unstructured_1_0.h>
#include <uavcan/primitive/array/Bit_1_0.h>
#include <uavcan/primitive/array/Integer16_1_0.h>
#include <uavcan/primitive/array/Integer32_1_0.h>
#include <uavcan/primitive/array/Integer64_1_0.h>
#include <uavcan/primitive/array/Integer8_1_0.h>
#include <uavcan/primitive/array/Natural16_1_0.h>
#include <uavcan/primitive/array/Natural32_1_0.h>
#include <uavcan/primitive/array/Natural64_1_0.h>
#include <uavcan/primitive/array/Natural8_1_0.h>
#include <uavcan/primitive/array/Real16_1_0.h>
#include <uavcan/primitive/array/Real32_1_0.h>
#include <uavcan/primitive/array/Real64_1_0.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */


typedef struct
{    
    uint8_t _tag_;
    union
    {
        uavcan_primitive_Empty_1_0 empty;
        uavcan_primitive_String_1_0 _string;
        uavcan_primitive_Unstructured_1_0 unstructured;
        uavcan_primitive_array_Bit_1_0 bit;
        uavcan_primitive_array_Integer64_1_0 integer64;
        uavcan_primitive_array_Integer32_1_0 integer32;
        uavcan_primitive_array_Integer16_1_0 integer16;
        uavcan_primitive_array_Integer8_1_0 integer8;
        uavcan_primitive_array_Natural64_1_0 natural64;
        uavcan_primitive_array_Natural32_1_0 natural32;
        uavcan_primitive_array_Natural16_1_0 natural16;
        uavcan_primitive_array_Natural8_1_0 natural8;
        uavcan_primitive_array_Real64_1_0 real64;
        uavcan_primitive_array_Real32_1_0 real32;
        uavcan_primitive_array_Real16_1_0 real16;
    };
} uavcan_register_Value_1_0;

/// Initialize an uavcan_register_Value_1_0 instance to default values.
/// No memory is allocated within this method.
/// Does nothing if @ref out_instance is NULL.
///
/// @param out_instance A structure instance to Initialize.
static inline void uavcan_register_Value_1_0_init(uavcan_register_Value_1_0* const out_instance)
{
    if (out_instance != NULL)
    {
        out_instance->_tag_ = 0;
        uavcan_primitive_Empty_1_0_init(&(out_instance->empty));
    }
}

/// Contains the maximum number of bytes needed to serialize a(n) uavcan_register_Value_1_0
/// instance.
#define uavcan_register_Value_1_0_MAX_SERIALIZED_REPRESENTATION_SIZE_BYTES \
        (259U)


/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// empty. If so, then uavcan_register_Value_1_0->empty
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_empty(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 0);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// string. If so, then uavcan_register_Value_1_0->string
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_string(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 1);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// unstructured. If so, then uavcan_register_Value_1_0->unstructured
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_unstructured(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 2);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// bit. If so, then uavcan_register_Value_1_0->bit
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_bit(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 3);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// integer64. If so, then uavcan_register_Value_1_0->integer64
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_integer64(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 4);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// integer32. If so, then uavcan_register_Value_1_0->integer32
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_integer32(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 5);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// integer16. If so, then uavcan_register_Value_1_0->integer16
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_integer16(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 6);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// integer8. If so, then uavcan_register_Value_1_0->integer8
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_integer8(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 7);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// natural64. If so, then uavcan_register_Value_1_0->natural64
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_natural64(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 8);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// natural32. If so, then uavcan_register_Value_1_0->natural32
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_natural32(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 9);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// natural16. If so, then uavcan_register_Value_1_0->natural16
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_natural16(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 10);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// natural8. If so, then uavcan_register_Value_1_0->natural8
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_natural8(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 11);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// real64. If so, then uavcan_register_Value_1_0->real64
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_real64(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 12);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// real32. If so, then uavcan_register_Value_1_0->real32
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_real32(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 13);
}

/// Determine if a given uavcan_register_Value_1_0 tagged union is currently tagged as
/// real16. If so, then uavcan_register_Value_1_0->real16
/// can be accessed safely.
static inline bool uavcan_register_Value_1_0_is_real16(const uavcan_register_Value_1_0* const tagged_union_ptr)
{
    return ((tagged_union_ptr != NULL) && tagged_union_ptr->_tag_ == 14);
}

/// Serialization of uavcan_register_Value_1_0 instance into a byte array.
///
/// @param in_instance   A structure instance to serialize.
/// @param offset        Offset (in bits) of data type in message.
/// @param out_buffer    Output message buffer.
///
/// @returns             Size of encoded data (in bits)
static inline NunavutSignedBitLength uavcan_register_Value_1_0_serialize(const uavcan_register_Value_1_0* in_instance, NunavutUnsignedBitLength offset, uint8_t* const out_buffer)
{
    NunavutSignedBitLength rc = 0;

    if (out_buffer == NULL)
    {
        return -NUNAVUT_ERR_INVALID_BUF;
    }
    
    // Begin Union: uavcan_register_Value_1_0
    nunavutSetUxx(out_buffer, offset, in_instance->_tag_, 8);
    offset += 8;
    if (uavcan_register_Value_1_0_is_empty(in_instance))
    {
        rc = uavcan_primitive_Empty_1_0_serialize(&(in_instance->empty), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_string(in_instance))
    {
        rc = uavcan_primitive_String_1_0_serialize(&(in_instance->_string), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_unstructured(in_instance))
    {
        rc = uavcan_primitive_Unstructured_1_0_serialize(&(in_instance->unstructured), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_bit(in_instance))
    {
        rc = uavcan_primitive_array_Bit_1_0_serialize(&(in_instance->bit), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer64(in_instance))
    {
        rc = uavcan_primitive_array_Integer64_1_0_serialize(&(in_instance->integer64), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer32(in_instance))
    {
        rc = uavcan_primitive_array_Integer32_1_0_serialize(&(in_instance->integer32), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer16(in_instance))
    {
        rc = uavcan_primitive_array_Integer16_1_0_serialize(&(in_instance->integer16), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer8(in_instance))
    {
        rc = uavcan_primitive_array_Integer8_1_0_serialize(&(in_instance->integer8), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural64(in_instance))
    {
        rc = uavcan_primitive_array_Natural64_1_0_serialize(&(in_instance->natural64), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural32(in_instance))
    {
        rc = uavcan_primitive_array_Natural32_1_0_serialize(&(in_instance->natural32), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural16(in_instance))
    {
        rc = uavcan_primitive_array_Natural16_1_0_serialize(&(in_instance->natural16), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural8(in_instance))
    {
        rc = uavcan_primitive_array_Natural8_1_0_serialize(&(in_instance->natural8), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real64(in_instance))
    {
        rc = uavcan_primitive_array_Real64_1_0_serialize(&(in_instance->real64), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real32(in_instance))
    {
        rc = uavcan_primitive_array_Real32_1_0_serialize(&(in_instance->real32), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real16(in_instance))
    {
        rc = uavcan_primitive_array_Real16_1_0_serialize(&(in_instance->real16), offset, out_buffer);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else
    {
        return -NUNAVUT_ERR_INVALID_TAG;
    }
    // End Union: uavcan_register_Value_1_0

    return offset;
}

/// Deserialization of byte-array encoding into uavcan_register_Value_1_0 instance.
///
/// @param out_instance      Structure instance to write data to.
/// @param offset            Bit offset of structure in data buffer.
/// @param in_buffer         Message buffer to deserialize.
/// @param buf_size_bytes    Length of input buffer (in bytes) to avoid overflow.
///
/// @returns                 Size of decoded data (in bits)
static inline NunavutSignedBitLength uavcan_register_Value_1_0_deserialize(uavcan_register_Value_1_0* const out_instance, NunavutUnsignedBitLength offset, uint8_t* const in_buffer, const size_t buf_size_bytes)
{
    NunavutSignedBitLength rc = 0;

    if (in_buffer == NULL)
    {
        return -NUNAVUT_ERR_INVALID_BUF;
    }
    
    // Begin Union: uavcan.register.Value.1.0
    out_instance->_tag_ = nunavutGetU8(in_buffer, buf_size_bytes, offset, 8);
    offset += 8;
    if (uavcan_register_Value_1_0_is_empty(out_instance))
    {
        rc = uavcan_primitive_Empty_1_0_deserialize(&(out_instance->empty), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_string(out_instance))
    {
        rc = uavcan_primitive_String_1_0_deserialize(&(out_instance->_string), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_unstructured(out_instance))
    {
        rc = uavcan_primitive_Unstructured_1_0_deserialize(&(out_instance->unstructured), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_bit(out_instance))
    {
        rc = uavcan_primitive_array_Bit_1_0_deserialize(&(out_instance->bit), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer64(out_instance))
    {
        rc = uavcan_primitive_array_Integer64_1_0_deserialize(&(out_instance->integer64), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer32(out_instance))
    {
        rc = uavcan_primitive_array_Integer32_1_0_deserialize(&(out_instance->integer32), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer16(out_instance))
    {
        rc = uavcan_primitive_array_Integer16_1_0_deserialize(&(out_instance->integer16), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_integer8(out_instance))
    {
        rc = uavcan_primitive_array_Integer8_1_0_deserialize(&(out_instance->integer8), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural64(out_instance))
    {
        rc = uavcan_primitive_array_Natural64_1_0_deserialize(&(out_instance->natural64), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural32(out_instance))
    {
        rc = uavcan_primitive_array_Natural32_1_0_deserialize(&(out_instance->natural32), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural16(out_instance))
    {
        rc = uavcan_primitive_array_Natural16_1_0_deserialize(&(out_instance->natural16), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_natural8(out_instance))
    {
        rc = uavcan_primitive_array_Natural8_1_0_deserialize(&(out_instance->natural8), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real64(out_instance))
    {
        rc = uavcan_primitive_array_Real64_1_0_deserialize(&(out_instance->real64), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real32(out_instance))
    {
        rc = uavcan_primitive_array_Real32_1_0_deserialize(&(out_instance->real32), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else if (uavcan_register_Value_1_0_is_real16(out_instance))
    {
        rc = uavcan_primitive_array_Real16_1_0_deserialize(&(out_instance->real16), offset, in_buffer, buf_size_bytes);
        if (rc < 0)
        {
            return rc;
        }
        offset = rc;
    }
    else
    {
        return -NUNAVUT_ERR_INVALID_TAG;
    }
    // End Union: uavcan.register.Value.1.0

    return offset;
}



#ifdef __cplusplus
} /* End extern "C" */
#endif /* __cplusplus */
#endif /* UAVCAN_REGISTER_VALUE */
