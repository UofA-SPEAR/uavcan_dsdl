// UAVCAN data structure definition.                                                                          +-+ +-+
//                                                                                                            | | | |
// AUTOGENERATED, DO NOT EDIT.                                                                                \  -  /
//                                                                                                              ---
//                                                                                                               o
// +------------------------------------------------------------------------------------------------------------------+
//
// Generator:
// nunavut-0.3.4 (serialization was enabled)
//
//
// Source File:
// /home/david/Documents/Clubs/SPEAR/uavcan_dsdl/public_regulated_data_types/uavcan/internet/udp/32750.OutgoingPacket.0.1.uavcan
//
// Template:
// StructureType.j2
//
// Generated at:  2020-08-21 01:54:43.797975 UTC
// Is deprecated: no
// Fixed port ID: 32750
// Full name:     uavcan.internet.udp.OutgoingPacket
// Version:       0.1

#ifndef UAVCAN_INTERNET_UDP_OUTGOING_PACKET_INCLUDED
#define UAVCAN_INTERNET_UDP_OUTGOING_PACKET_INCLUDED

#include <nunavut/support/nunavut.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

#define uavcan_internet_udp_OutgoingPacket_0_1_NAT_ENTRY_MIN_TTL (86400)

typedef struct
{
    uint16_t session_id;
    uint16_t destination_port;
    size_t destination_address_length;
    uint8_t destination_address[45];
    bool use_masquerading;
    bool use_dtls;
    size_t payload_length;
    uint8_t payload[260];
} uavcan_internet_udp_OutgoingPacket_0_1;

/// The maximum capacity of uavcan_internet_udp_OutgoingPacket_0_1.destination_address.
static inline size_t uavcan_internet_udp_OutgoingPacket_0_1_destination_address_array_capacity(void)
{
    return (45U);
}

/// If true then uavcan_internet_udp_OutgoingPacket_0_1.destination_address's length can vary otherwise it will
/// always be the same as its capacity.
static inline bool uavcan_internet_udp_OutgoingPacket_0_1_destination_address_array_is_variable_length(void)
{
    return (true);
}

/// If uavcan_internet_udp_OutgoingPacket_0_1.destination_address is a variable length array then this is the current
/// number of items populated in the array starting from index 0. If destination_address is not a variable length array
/// then this is the same as its capacity.
static inline size_t uavcan_internet_udp_OutgoingPacket_0_1_destination_address_array_length(
    const uavcan_internet_udp_OutgoingPacket_0_1* const instance)
{
    return (instance == NULL) ? 0 : instance->destination_address_length;
}

/// The maximum capacity of uavcan_internet_udp_OutgoingPacket_0_1.payload.
static inline size_t uavcan_internet_udp_OutgoingPacket_0_1_payload_array_capacity(void)
{
    return (260U);
}

/// If true then uavcan_internet_udp_OutgoingPacket_0_1.payload's length can vary otherwise it will
/// always be the same as its capacity.
static inline bool uavcan_internet_udp_OutgoingPacket_0_1_payload_array_is_variable_length(void)
{
    return (true);
}

/// If uavcan_internet_udp_OutgoingPacket_0_1.payload is a variable length array then this is the current
/// number of items populated in the array starting from index 0. If payload is not a variable length array
/// then this is the same as its capacity.
static inline size_t uavcan_internet_udp_OutgoingPacket_0_1_payload_array_length(
    const uavcan_internet_udp_OutgoingPacket_0_1* const instance)
{
    return (instance == NULL) ? 0 : instance->payload_length;
}

/// Initialize an uavcan_internet_udp_OutgoingPacket_0_1 instance to default values.
/// No memory is allocated within this method.
/// Does nothing if @ref out_instance is NULL.
///
/// @param out_instance A structure instance to Initialize.
static inline void uavcan_internet_udp_OutgoingPacket_0_1_init(uavcan_internet_udp_OutgoingPacket_0_1* const out_instance)
{
    if (out_instance != NULL)
    {
        out_instance->session_id = 0;
        out_instance->destination_port = 0;
        out_instance->destination_address_length = 0;
        out_instance->use_masquerading = 0;
        out_instance->use_dtls = 0;
        /* Ignoring 6 padding bit(s). */
        out_instance->payload_length = 0;
    }
}

/// Contains the maximum number of bytes needed to serialize a(n) uavcan_internet_udp_OutgoingPacket_0_1
/// instance.
#define uavcan_internet_udp_OutgoingPacket_0_1_MAX_SERIALIZED_REPRESENTATION_SIZE_BYTES \
        (313U)



/// uavcan_internet_udp_OutgoingPacket_0_1 can only be used with the fixed port identifier defined here.
#define uavcan_internet_udp_OutgoingPacket_0_1_FIXED_PORT_ID (32750U)
/// Serialization of uavcan_internet_udp_OutgoingPacket_0_1 instance into a byte array.
///
/// @param in_instance   A structure instance to serialize.
/// @param offset        Offset (in bits) of data type in message.
/// @param out_buffer    Output message buffer.
///
/// @returns             Size of encoded data (in bits)
static inline NunavutSignedBitLength uavcan_internet_udp_OutgoingPacket_0_1_serialize(const uavcan_internet_udp_OutgoingPacket_0_1* in_instance, NunavutUnsignedBitLength offset, uint8_t* const out_buffer)
{
    NunavutSignedBitLength rc = 0;

    if (out_buffer == NULL)
    {
        return -NUNAVUT_ERR_INVALID_BUF;
    }
    
    // Begin Structure: saturated uint16
    
        nunavutSetUxx(out_buffer, offset, in_instance->session_id, 16);
        offset += 16;
    // End Structure: saturated uint16
    // Begin Structure: saturated uint16
    
        nunavutSetUxx(out_buffer, offset, in_instance->destination_port, 16);
        offset += 16;
    // End Structure: saturated uint16
    // Begin Structure: saturated uint8[<=45]
    
        if (in_instance->destination_address_length > 45)
        {
            return -NUNAVUT_ERR_INVALID_LEN;
        }
        nunavutSetUxx(out_buffer, offset, in_instance->destination_address_length, 8);
        offset += 8;
        memcpy((void*) out_buffer + (offset>> 3), (void*)in_instance->destination_address, in_instance->destination_address_length * 1);
        offset += in_instance->destination_address_length * 8;
    // End Structure: saturated uint8[<=45]
    // Begin Structure: saturated bool
    
        nunavutSetBit(out_buffer, offset, in_instance->use_masquerading);
        offset += 1;
    // End Structure: saturated bool
    // Begin Structure: saturated bool
    
        nunavutSetBit(out_buffer, offset, in_instance->use_dtls);
        offset += 1;
    // End Structure: saturated bool
    // Begin Structure: void6
    offset += 6;
    // End Structure: void6
    // Begin Structure: saturated uint8[<=260]
    
        if (in_instance->payload_length > 260)
        {
            return -NUNAVUT_ERR_INVALID_LEN;
        }
        nunavutSetUxx(out_buffer, offset, in_instance->payload_length, 16);
        offset += 16;
        memcpy((void*) out_buffer + (offset>> 3), (void*)in_instance->payload, in_instance->payload_length * 1);
        offset += in_instance->payload_length * 8;
    // End Structure: saturated uint8[<=260]

    return offset;
}

/// Deserialization of byte-array encoding into uavcan_internet_udp_OutgoingPacket_0_1 instance.
///
/// @param out_instance      Structure instance to write data to.
/// @param offset            Bit offset of structure in data buffer.
/// @param in_buffer         Message buffer to deserialize.
/// @param buf_size_bytes    Length of input buffer (in bytes) to avoid overflow.
///
/// @returns                 Size of decoded data (in bits)
static inline NunavutSignedBitLength uavcan_internet_udp_OutgoingPacket_0_1_deserialize(uavcan_internet_udp_OutgoingPacket_0_1* const out_instance, NunavutUnsignedBitLength offset, uint8_t* const in_buffer, const size_t buf_size_bytes)
{
    NunavutSignedBitLength rc = 0;

    if (in_buffer == NULL)
    {
        return -NUNAVUT_ERR_INVALID_BUF;
    }
    
    // Begin Structure: saturated uint16
    out_instance->session_id = nunavutGetU16(in_buffer, buf_size_bytes, offset, 16);
    offset += 16;
    // End Structure: saturated uint16
    // Begin Structure: saturated uint16
    out_instance->destination_port = nunavutGetU16(in_buffer, buf_size_bytes, offset, 16);
    offset += 16;
    // End Structure: saturated uint16
    // Begin Structure: saturated uint8[<=45]
    
    out_instance->destination_address_length = nunavutGetU8(in_buffer, buf_size_bytes, offset, 8);;
    offset += 8;
    if (out_instance->destination_address_length > 45)
    {
        return -NUNAVUT_ERR_INVALID_LEN;
    }
    memcpy((void*)out_instance->destination_address, (void*) in_buffer + (offset >> 3), out_instance->destination_address_length * 1);
    offset += out_instance->destination_address_length * 8;
    // End Structure: saturated uint8[<=45]
    // Begin Structure: saturated bool
    out_instance->use_masquerading = nunavutGetBit(in_buffer, buf_size_bytes, offset);
    offset += 1;
    // End Structure: saturated bool
    // Begin Structure: saturated bool
    out_instance->use_dtls = nunavutGetBit(in_buffer, buf_size_bytes, offset);
    offset += 1;
    // End Structure: saturated bool
    // Begin Structure: void6
    offset += 6;
    // End Structure: void6
    // Begin Structure: saturated uint8[<=260]
    
    out_instance->payload_length = nunavutGetU16(in_buffer, buf_size_bytes, offset, 16);;
    offset += 16;
    if (out_instance->payload_length > 260)
    {
        return -NUNAVUT_ERR_INVALID_LEN;
    }
    memcpy((void*)out_instance->payload, (void*) in_buffer + (offset >> 3), out_instance->payload_length * 1);
    offset += out_instance->payload_length * 8;
    // End Structure: saturated uint8[<=260]

    return offset;
}


#ifdef __cplusplus
} /* End extern "C" */
#endif /* __cplusplus */
#endif /* UAVCAN_INTERNET_UDP_OUTGOING_PACKET */
