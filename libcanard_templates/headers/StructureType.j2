{% extends "common_header.j2" %}
{% block contents %}

#include <stdint.h>
{% for attr in T.attributes %}
  {%- if attr.data_type is StructureType %}
#include "{{attr.data_type.full_name.replace('.','/')}}_{{attr.data_type.version[0]}}_{{attr.data_type.version[1]}}.h"
  {%- endif %}
{%- endfor %}

/** @brief Auto-generated data structure for interacting with {{ T.full_name }} messages.
 */
struct {
{%- for attr in T.attributes %}
  {%- if attr.data_type is not StructureType %}
  {{ attr.data_type | type_from_primitive(use_standard_types=True) }} {{ attr.name }};
  {%- else %}
  {{ attr.data_type.full_name.replace('.','_') }} {{ attr.name }};
  {%- endif %}
{%- endfor %}
} {{ c_name }};

/** @brief Auto-generated UAVCAN encoding function.
 *
 * @param[in] data	Data to encode
 * @param[in] offset	Offset of data in buffer, useful for nesting data types
 * @param[out] buf	Memory buffer - must have enough data for the max length
 *
 * @retval Length of encoded data (in bits)
 */
unsigned int {{ c_name }}_encode(uint8_t *buf, unsigned int offset, struct {{c_name}} *data);

/** @brief Auto-generated UAVCAN decoding function.
 *
 * @param[in] buf	Pointer to memory buffer where message is located
 * @param[in] buf_len	Length of buffer
 * @param[in] offset	Offset of data in buffer, useful for nesting data types
 * @param[out] data	Data in a usable form.
 */
void {{ c_name }}_decode(uint8_t *buf, unsigned int buf_len, unsigned int offset, struct {{c_name}} *data);

{% endblock %}
